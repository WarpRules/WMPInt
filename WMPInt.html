<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>WMPInt 0.6.4 documentation</title>
  <style type="text/css"> <!--
html
{
  background-color: #DDDDDD;
}

body
{
  background-color: white;
  margin-left: 5%;
  margin-top: 16px;
  margin-right: 5%;
  padding-top: 2em;
  padding-left: 7%;
  padding-right: 7%;
  padding-bottom: 2%;
  border-color: black;
  border: solid;
  border-width: 1px;
}

h1
{
  text-align: center;
  background-color: #FFEEA0;
  padding-bottom: 0.2em;
  padding-top: 0.1em;
}

h2
{
  background-color: #FFE0A0;
  padding-left: 0.5em;
}

h3
{
  background-color: #FFFFA0;
}

h4
{
  background-color: #FFFFD0;
}

li
{
  padding-top: 0.3em;
}

pre
{
  background-color: #F0E8E0;
  padding-left: 1em;
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-color: black;
  border: solid;
  border-width: 1px;
}

.synopsis
{
  background-color: #E0E0F0;
}

code
{
  font-family: monospace;
  color: #206000;
}

.comment
{
  color: #008000;
}

.funcname
{
  color: #0050FF;
}

.important
{
  background-color: #B00000;
  color: #FFFFFF;
  padding-left: 0.5em;
  padding-right: 0.5em;
}
--> </style>
</head>

<body>
<h1>WMPInt 0.6.4 documentation</h1>

<p><code>WMPUInt</code> and <code>WMPInt</code> (not yet implemented) are templated
  classes that implement multi-precision integer arithmetic for x86-64 platforms
  in C++17 and inline asm. They allow using arbitrarily large integers, of a size
  determined at compile time. This library aims for maximum speed and efficiency.</p>

<p>Sizes of the integers are defined in multiples of 64 bits. Example of using 1024-bit
  unsigned integers:</p>

<pre>WMPUInt&lt;16&gt; a(10), b(20), c(30); <span class="comment">// 1024-bit integers</span>
WMPUInt&lt;16&gt; result = a + b * c;</pre>

<p>For efficiency, these classes do not perform any dynamic memory allocations.</p>

<p>Note that these classes use x86-64 inline asm, which means support is restricted
  to such targets, using compatible compilers (modern gcc and clang tested, icc may work).</p>

<h4>Table of contents:</h4>

<ul>
  <li><a href="#license">License</a></li>
  <li><a href="#summary">Feature and usage summary</a></li>
  <li><a href="#compatibility">Compiler and platform compatibility</a></li>
  <li>Function reference</li>
  <ul>
    <li><a href="#initialization">Value initialization</a></li>
    <li><a href="#data">Data retrieval</a></li>
    <li><a href="#basicfunctions">Basic math operators</a></li>
    <ul>
      <li><a href="#comparison">Comparison operators</a></li>
      <li><a href="#bitwise">Bitwise operators</a></li>
      <li><a href="#arithmetic">Arithmetic operators</a></li>
    </ul>
    <li><a href="#specialfunctions">Special math functions</a></li>
    <ul>
      <li><a href="#multiply">Multiplying very large integers</a></li>
      <li><a href="#fullmultiply">Full multiplication</a></li>
      <li><a href="#divmod">Division and modulo</a></li>
      <li><a href="#bitshift">Bit-shifting by a compile-time constant</a></li>
    </ul>
    <li><a href="#printing">ASCII output</a></li>
  </ul>
  <li><a href="#notyetsupported">Not yet supported features</a></li>
  <li><a href="#tips">Efficiency tips</a></li>
  <ul>
    <li><a href="#copying">Copying and temporaries</a></li>
    <li><a href="#smalloperands">Small operands</a></li>
    <li><a href="#multiplication">Multiplication</a></li>
    <li><a href="#exproptimization">Expression optimizations</a></li>
    <li><a href="#longvskaratsuba">Full multiplication with long vs. Karatsuba algorithm</a></li>
    <li><a href="#extremelylargevalues">Creating extremely large values</a></li>
  </ul>
</ul>

<!---------------------------------------------------------------------------->
<h2 id="license">License</h2>

<p>The source code of this software is published under the MIT license.</p>

<p>Copyright (c) 2019 Juha Nieminen

<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>

<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>

<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>

<!---------------------------------------------------------------------------->
<h2 id="summary">Feature and usage summary</h2>

<p>The library consists of the header file <code>WMPInt.hh</code> and the source file
  <code>WMPInt.cc</code> (the latter of which should be compiled into the program.)</p>

<p>To use the class, include the <code>WMPInt.hh</code> header file in your code.</p>

<pre>#include "WMPInt.hh"</pre>

<p>Class declaration:</p>

<pre class="synopsis">template&lt;std::size_t kSize&gt;
class WMPUInt;</pre>

<p>The classes work very similarly to <code>std::array&lt;std::uint64_t, kSize&gt;</code>,
  containing an array of 64-bit integers inside them. The template parameter specifies the size
  of the array. They work like integers of <code>kSize*64</code> bits. They provide most of the
  integer operators, and aim for maximum efficiency and speed. Like <code>std::array</code>,
  their size is determined at compile time, and they do not perform any dynamic memory
  allocations.</p>

<p>Instances of these classes can be used like unsigned and signed integers respectively.
  For example:</p>

<pre>WMPUInt&lt;16&gt; a(10), b(20), c(30); <span class="comment">// 1024-bit integers</span>
c += b;
c -= a;
a *= c;
b = a*a + b*b + c*c;</pre>

<p>Note, however, the <a href="#tips">tips about the most efficient ways to use these classes</a>
  at the end of this documentation.</p>

<p>Instances can be initialized with a value with either direct numerical values or from
  an ASCII string. Consult the <a href="#initialization">value initialization</a> section
  below for details.</p>

<!---------------------------------------------------------------------------->
<h2 id="compatibility">Compiler and platform compatibility</h2>

<p>These classes use x86-64 inline assembly for efficiency. They have been tested with the
  following platforms and compilers:</p>

<ul>
  <li>Windows 10: mingw64 (gcc 7.1.0)</li>
  <li>Linux: gcc (7, 8 and 9), clang (5, 6 and 7)</li>
  <li>macOS High Sierra: Apple LLVM version 10.0.0 (clang-1000.11.45.5)</li>
</ul>

<p>Note that the classes require C++17, so the <code>-std=c++17</code> compiler
  option or bigger may be necessary.</p>

<!---------------------------------------------------------------------------->
<h2 id="initialization">Value initialization</h2>

<p>There are two main ways to initialize an instance of <code>WMPUInt</code> with a value:
  Providing <code>std::uint64_t</code> values to its constructor or the <code>assign()</code>
  function, or with an ASCII string containing the number in either decimal or hexadecimal.</p>

<h3>Initialization with <code>std::uint64_t</code> values</h3>

<p><b>Member functions:</b></p>

<pre class="synopsis">WMPUInt();

explicit <span class="funcname">WMPUInt</span> (std::uint64_t);

template&lt;typename... Values_t&gt;
explicit <span class="funcname">WMPUInt</span> (std::uint64_t, Values_t...);

explicit <span class="funcname">WMPUInt</span> (std::initializer_list&lt;std::uint64_t&gt;);

template&lttypename... Values_t&gt;
void <span class="funcname">assign</span> (std::uint64_t, Values_t...);

void <span class="funcname">assign</span> (std::initializer_list&lt;std::uint64_t&gt;);</pre>

<p>The default constructor will leave this object uninitialized (thus its value will
  be unspecified, just as with basic types.) To zero-initialize the object, simply
  give the constructor the value <code>0</code>.</p>

<p>The constructor can be given at most <code>kSize</code> values of type
  <code>std::uint64_t</code>, which will form the value of this object. The values
  are listed from most-significant to least-significant. If there are less values
  specified than <code>kSize</code>, the given values will form the least-significant
  elements of this object (the remaining most-significant elements will be initialized
  to zero.) Examples:</p>

<pre>WMPUInt&lt;3&gt; v1(10);
WMPUInt&lt;3&gt; v2(0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF);
WMPUInt&lt;3&gt; v3(0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF);</pre>

<p>These are the values of the three example objects above, in decimal:</p>

<p><code>v1</code>: 10<br />
  <code>v2</code>: 340282366920938463463374607431768211455<br />
  <code>v3</code>: 6277101735386680763835789423207666416102355444464034512895</p>

<p>Alternatively, the objects can be constructed or assigned a value using an
  initializer list of <code>std::uint64_t</code> values.</p>

<p>Note that the <code>data()</code> member function returns a pointer to the internal
  array of the object. This can also be used to directly set (and read) these components.</p>

<h3>Initialization with an ASCII string</h3>

<p>Alternatively, the object can be initialized with an ASCII string containing a number
  in either decimal or hexadecimal.</p>

<p><b>Member functions:</b></p>

<pre class="synopsis">const char* <span class="funcname">assignFromHexStr</span> (const char*);
const char* <span class="funcname">assignFromDecStr</span> (const char*);</pre>

<p>The functions will do very little sanity checks on the strings. They will simply
  scan the string until they find a non-hexadecimal (in the first case) or non-decimal
  (in the second case) character, or the null character, and interpret the characters
  up to that point. Hexadecimal characters can be in uppercase or lowercase. They return
  a pointer to the position in the string where the scan was stopped.</p>

<p>Currently a leading <code>'-'</code> character is not supported.</p>

<p>If the string contains a value that's larger than fits the current object, its least-significant
  part will be assigned (in other words, the value will be truncated, ie. taken modulo the maximum
  value of this object). Currently no direct mechanism is implemented to know if this happens, but
  this can be deduced in the following manner:</p>

<ul>
  <li>For hexadecimal strings: If the difference between the returned pointer and the original
    pointer is larger than <code>maxHexadecimalDigits()</code>, then the value was truncated,
    else it was not.</li>
  <li>For decimal strings: If the difference between the pointers is larger than
    <code>maxDecimalDigits()</code> then it was truncated. If it's smaller than that value then
    it was not truncated. If it's exactly that value, then it might or might not have been
    truncated. (Currently there is no mechanism implemented to know this for sure.)</li>
</ul>

<p>Note, however, that this does not take into account possible leading <code>'0'</code> characters
  in the input string. If determining whether truncation happened is important, these leading
  characters should be skipped prior to calling these functions.</p>

<p>(If it's absolutely crucial to know if the value of an input decimal string was truncated,
  then one sure way is to use a temporary <code>WMPUInt</code> object that's one larger than
  the target object, then read the decimal string value into it, and if the difference between
  pointers is exactly <code>maxDecimalDigits()</code> of the target object, check if
  <code>data()[0]</code> of this temporary object is zero. If it's not, then the value
  was truncated. After this, the temporary object can be assigned to the target object
  using <code>assign()</code>.)</p>

<p>If possible, using <code>assignFromHexStr()</code> is recommended because it's
  <em>significantly</em> more efficient than <code>assignFromDecStr()</code>.</p>

<p>Examples (which are equivalent to the previous examples above):</p>

<pre>v1.assignFromHexStr("A");
v2.assignFromHexStr("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");
v3.assignFromHexStr("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");

v1.assignFromDecStr("10");
v2.assignFromDecStr("340282366920938463463374607431768211455");
v3.assignFromDecStr("6277101735386680763835789423207666416102355444464034512895");</pre>

<h3>Initialization with another <code>WMPUInt</code> object</h3>

<p><b>Member functions:</b></p>

<pre class="synopsis">template&lt;std::size_t kSize2&gt;
void <span class="funcname">assign</span> (const WMPUInt&lt;kSize2&gt;&amp;);</pre>

<p>An object of one size can also be assigned with the value of an object of another size.
  If the size of the parameter is larger than the size of this object, the least-significant
  components will be assigned (in other words, the parameter value will be taken modulo the
  size of this object.)</p>


<!---------------------------------------------------------------------------->
<h2 id="data">Data retrieval</h2>

<p><b>Member functions:</b></p>

<pre class="synopsis">constexpr static std::size_t <span class="funcname">size</span>();
constexpr static std::size_t <span class="funcname">bits</span>();
std::uint64_t*               <span class="funcname">data</span>();
const std::uint64_t*         <span class="funcname">data</span>() const;</pre>

<p><code>size()</code> simply returns <code>kSize</code>.</p>

<p><code>bits()</code> returns the size of this object in bits (which is always
  <code>kSize*64</code>, but provided for convenience.)</p>

<p><code>data()</code> returns a pointer to the internal array of component values.
  The calling code is free to read and modify these values. <code>data()[0]</code> is
  the most-significant component, and <code>data()[kSize-1]</code> is the least-significant
  component.</p>


<!---------------------------------------------------------------------------->
<h2 id="basicfunctions">Basic math operators</h2>

<h3 id="comparison">Comparison operators</h3>

<p><b>Member functions:</b></p>

<pre class="synopsis">bool <span class="funcname">operator==</span> (const WMPUInt&lt;kSize&gt;&amp;) const;
bool <span class="funcname">operator==</span> (std::uint64_t) const;
bool <span class="funcname">operator!=</span> (const WMPUInt&lt;kSize&gt;&amp;) const;
bool <span class="funcname">operator!=</span> (std::uint64_t) const;
bool <span class="funcname">operator&lt;</span>  (const WMPUInt&lt;kSize&gt;&amp;) const;
bool <span class="funcname">operator&lt;</span>  (std::uint64_t) const;
bool <span class="funcname">operator&lt;=</span> (const WMPUInt&lt;kSize&gt;&amp;) const;
bool <span class="funcname">operator&lt;=</span> (std::uint64_t) const;
bool <span class="funcname">operator&gt;</span>  (const WMPUInt&lt;kSize&gt;&amp;) const;
bool <span class="funcname">operator&gt;</span>  (std::uint64_t) const;
bool <span class="funcname">operator&gt;=</span> (const WMPUInt&lt;kSize&gt;&amp;) const;
bool <span class="funcname">operator&gt;=</span> (std::uint64_t) const;</pre>

<p><b>Non-member functions:</b></p>

<pre class="synopsis">bool <span class="funcname">operator==</span> (std::uint64_t, const WMPUInt&lt;kSize&gt;&amp;);
bool <span class="funcname">operator!=</span> (std::uint64_t, const WMPUInt&lt;kSize&gt;&amp;);
bool <span class="funcname">operator&lt;</span>  (std::uint64_t, const WMPUInt&lt;kSize&gt;&amp;);
bool <span class="funcname">operator&lt;=</span> (std::uint64_t, const WMPUInt&lt;kSize&gt;&amp;);
bool <span class="funcname">operator&gt;</span>  (std::uint64_t, const WMPUInt&lt;kSize&gt;&amp;);
bool <span class="funcname">operator&gt;=</span> (std::uint64_t, const WMPUInt&lt;kSize&gt;&amp;);</pre>

<h3 id="bitwise">Bitwise operators</h3>

<p><b>Member functions:</b></p>

<pre class="synopsis">WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator&amp;=</span>  (const WMPUInt&lt;kSize&gt;&amp;);
WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator&amp;=</span>  (std::uint64_t);
WMPUInt&lt;kSize&gt;  <span class="funcname">operator&amp;</span>   (const WMPUInt&lt;kSize&gt;&amp;) const;
WMPUInt&lt;kSize&gt;  <span class="funcname">operator&amp;</span>   (std::uint64_t) const;
WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator|=</span>  (const WMPUInt&lt;kSize&gt;&amp;);
WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator|=</span>  (std::uint64_t);
WMPUInt&lt;kSize&gt;  <span class="funcname">operator|</span>   (const WMPUInt&lt;kSize&gt;&amp;) const;
WMPUInt&lt;kSize&gt;  <span class="funcname">operator|</span>   (std::uint64_t) const;
WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator^=</span>  (const WMPUInt&lt;kSize&gt;&amp;);
WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator^=</span>  (std::uint64_t);
WMPUInt&lt;kSize&gt;  <span class="funcname">operator^</span>   (const WMPUInt&lt;kSize&gt;&amp;) const;
WMPUInt&lt;kSize&gt;  <span class="funcname">operator^</span>   (std::uint64_t) const;
WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator&lt;&lt;=</span> (std::size_t);
WMPUInt&lt;kSize&gt;  <span class="funcname">operator&lt;&lt;</span>  (std::size_t) const;
WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator&gt;&gt;=</span> (std::size_t);
WMPUInt&lt;kSize&gt;  <span class="funcname">operator&gt;&gt;</span>  (std::size_t) const;</pre>

<p><b>Non-member functions:</b></p>

<pre class="synopsis">WMPUInt&lt;kSize&gt; <span class="funcname">operator&amp;</span> (std::uint64_t, const WMPUInt&lt;kSize&gt;&amp;);
WMPUInt&lt;kSize&gt; <span class="funcname">operator|</span> (std::uint64_t, const WMPUInt&lt;kSize&gt;&amp;);
WMPUInt&lt;kSize&gt; <span class="funcname">operator^</span> (std::uint64_t, const WMPUInt&lt;kSize&gt;&amp;);</pre>

<p><b class="important">Important!</b> Calling the bit-shift operators
  (<code>operator&lt;&lt;=</code> etc.) with a bit size equal to or larger than
  <code>bits()</code> is undefined behavior (like it is with basic types), and will result
  in an out-of-bounds access. If these functions might be called with an amount that exceeds
  that limit, the calling code needs to check for this situation.</p>

<h3 id="arithmetic">Arithmetic operators</h3>

<p><b>Member functions:</b></p>

<pre class="synopsis">WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator+=</span> (const WMPUInt&lt;kSize&gt;&amp;);
WMPUInt&lt;kSize&gt;  <span class="funcname">operator+</span>  (const WMPUInt&lt;kSize&gt;&amp;) const;
WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator+=</span> (std::uint64_t);
WMPUInt&lt;kSize&gt;  <span class="funcname">operator+</span>  (std::uint64_t) const;
WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator-=</span> (const WMPUInt&lt;kSize&gt;&amp;);
WMPUInt&lt;kSize&gt;  <span class="funcname">operator-</span>  (const WMPUInt&lt;kSize&gt;&amp;) const;
WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator-=</span> (std::uint64_t);
WMPUInt&lt;kSize&gt;  <span class="funcname">operator-</span>  (std::uint64_t) const;
WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator++</span> ();
WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator--</span> ();
WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator*=</span> (const WMPUInt&lt;kSize&gt;&amp;);
WMPUInt&lt;kSize&gt;  <span class="funcname">operator*</span>  (const WMPUInt&lt;kSize&gt;&amp;) const;
WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator*=</span> (std::uint64_t);
WMPUInt&lt;kSize&gt;  <span class="funcname">operator*</span>  (std::uint64_t) const;
WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator/=</span> (std::uint64_t);
WMPUInt&lt;kSize&gt;  <span class="funcname">operator/</span>  (std::uint64_t) const;
WMPUInt&lt;kSize&gt;&amp; <span class="funcname">operator%=</span> (std::uint64_t);
WMPUInt&lt;kSize&gt;  <span class="funcname">operator%</span>  (std::uint64_t) const;
WMPUInt&lt;kSize&gt;  <span class="funcname">operator-</span>  () const;

void neg ();</pre>

<p><b>Non-member functions:</b></p>

<pre class="synopsis">WMPUInt&lt;kSize&gt; <span class="funcname">operator+</span> (std::uint64_t, const WMPUInt&lt;kSize&gt;&amp;);
WMPUInt&lt;kSize&gt; <span class="funcname">operator-</span> (std::uint64_t, const WMPUInt&lt;kSize&gt;&amp;);
WMPUInt&lt;kSize&gt; <span class="funcname">operator*</span> (std::uint64_t, const WMPUInt&lt;kSize&gt;&amp;);</pre>

<p><b class="important">Important!</b> The division and modulo operators <em>do not</em> check for
  division by zero. Dividing by zero will most probably cause the CPU to throw an exception
  (which eg. in Linux will cause the program to throw a SIGFPE signal.) Checking if the divisor
  is zero (before calling the division operators) is up to the calling code.</p>

<p>Note 1: The postfix versions of <code>operator++</code> and <code>operator--</code>
  are <em>deliberately</em> omitted because of their (needless) overhead.</p>

<p>Note 2: If possible, always use the <code>neg()</code> function instead of using the
  unary negation operator, as <code>neg()</code> negates the number in-place, while
  the unary negation operator will calculate the result into and return a temporary.</p>

<!---------------------------------------------------------------------------->
<h2 id="specialfunctions">Special math functions</h2>

<h3 id="multiply">Multiplying very large integers</h3>

<p><b>Member functions:</b></p>

<pre class="synopsis">constexpr static std::size_t <span class="funcname">multiplyBufferSize</span> ();

void <span class="funcname">multiply</span> (const WMPUInt&lt;kSize&gt;&amp; rhs,
               WMPUInt&lt;kSize&gt;&amp; result,
               std::uint64_t* tempBuffer) const;

void <span class="funcname">multiply</span> (std::uint64_t rhs, WMPUInt&lt;kSize&gt;&amp; result) const;
</pre>

<p>Note that the multiplication operators <code>operator*()</code> and <code>operator*=()</code>
  use internally a stack-allocated <code>WMPUInt&lt;kSize&gt;</code> and a buffer of
  <code>multiplyBufferSize()</code> <code>std::uint64_t</code> values. For values of
  <code>kSize</code> up to the hundreds, perhaps even thousands, this shouldn't pose a problem.
  However, if <code>kSize</code> is extremely large (in the tens of thousands or more), this
  may pose a problem because in most platforms stack size is limited, and this could cause a stack
  overflow. It might also potentially have some efficiency implications (even when the stack
  does not overflow).</p>

<p>These two member functions are provided to circumvent this problem.</p>

<p><code>tempBuffer</code> should be a (separate) array of at least
  <code>multiplyBufferSize()</code> <code>std::uint64_t</code> values. (This array doesn't
  need to be initialized with anything.)</p>

<p><b class="important">Important!</b> <code>result</code> cannot be this object or the
  <code>rhs</code> object. It must be a third, separate object, else the result will be
  completely incorrect. (Likewise <code>tempBuffer</code> cannot point to any of those three
  objects.)</p>

<p>The idea with these functions is that they can be used with temporary buffers that
  are statically or dynamically (but not stack) allocated, avoiding the problem of
  stack overflows. For example:</p>

<pre>namespace
{
    const std::size_t kSize = 10000;

    thread_local WMPUInt&lt;kSize&gt; multResult;
    thread_local std::uint64_t multTempBuf
    [WMPUInt&lt;kSize&gt;::multiplyBufferSize()];
}

void foo(const WMPUInt&lt;kSize&gt;&amp; value1,
         const WMPUInt&lt;kSize&gt;&amp; value2)
{
    value1.multiply(value2, multResult, multTempBuf);

    <span class="comment">// The result of the multiplication will be in multResult</span>
}</pre>


<!---------------------------------------------------------------------------->
<h3 id="fullmultiply">Full multiplication</h3>

<p><b>Member functions:</b></p>

<pre class="synopsis">template&lt;std::size_t kSize2&gt;
constexpr static std::size_t <span class="funcname">fullMultiplyBufferSize</span> ();

template&lt;std::size_t kSize2&gt;
void <span class="funcname">fullMultiply</span> (const WMPUInt&lt;kSize2&gt;&amp;,
                   WMPUInt&lt;kSize+kSize2&gt;&amp; result) const;

template&lt;std::size_t kSize2&gt;
void <span class="funcname">fullMultiply</span> (const WMPUInt&lt;kSize2&gt;&amp; rhs,
                   WMPUInt&lt;kSize+kSize2&gt;&amp; result,
                   std::uint64_t* tempBuffer) const;</pre>

<p>The multiplication operators (<code>operator*()</code> and <code>operator*=()</code>)
  and the <code>multiply()</code> function will return the result of the multiplication
  truncated to the same size as the input operands. The <code>fullMultiply()</code> function
  can be used to get the full result of the multiplication of two values of any size.</p>

<p>Given two values <code>WMPUInt&lt;size1&gt;</code> and <code>WMPUInt&lt;size2&gt;</code>,
  the result of their product will be an object of type
  <code>WMPUInt&lt;size1+size2&gt;</code>.</p>

<p>(Note that there is no version of the <code>fullMultiply()</code> function that would
  take a multiplier of type <code>std::uint64_t</code>. However, the exact same result
  (exactly as efficiently) can be obtained by using a multiplier of type
  <code>WMPUInt&lt;1&gt;</code> instead.)</p>

<p>Example usage:</p>

<pre>WMPUInt&lt;64&gt; value1, value2;
WMPUInt&lt;128&gt; result;

value1.fullMultiply(value2, result);</pre>

<p>The second version of the function takes a temporary buffer for intermediate result
  calculations (like the regular <code>multiply()</code> function does), which may be necessary
  for very large values, or in some cases for efficiency. The size of the buffer can be retrieved
  with <code>fullMultiplyBufferSize()</code>, which is a template function taking the size of the
  second operand as parameter. Example usage:</p>

<pre>WMPUInt&lt;512&gt; value1;
WMPUInt&lt;1000&gt; value2;
WMPUInt&lt;512+1000&gt; result;

const std::size_t kTempBufferSize =
    WMPUInt&lt;512&gt;::fullMultiplyBufferSize&lt;1000&gt;();
std::uint64_t tempBuffer[kTempBufferSize];

value1.fullMultiply(value2, result, tempBuffer);</pre>

<!---------------------------------------------------------------------------->
<h3 id="divmod">Division and modulo</h3>

<p>(Note: This section is still incomplete. It will be updated as the functions get
  implemented.)</p>

<p><b>Member functions:</b></p>

<pre class="synopsis">std::uint64_t <span class="funcname">divide</span> (std::uint64_t, WMPUInt&lt;kSize&gt;&amp; result) const;

std::uint64_t <span class="funcname">modulo</span> (std::uint64_t rhs) const;</pre>

<p>If you need the quotient <em>and</em> remainder of a division operation, it's much more
  efficient to get them both at the same time with a single function call, rather than calling
  <code>operator/()</code> and <code>operator%()</code> separately (as doing so would be
  calculating the exact same division twice).</p>

<p>The <code>divide()</code> member function taking a <code>std::uint64_t</code> divisor value
  works similarly in usage to the equivalent <code>multiply()</code> function does, except that
  it also returns the remainder of the division. (Calling this function is essentially "free"
  in terms of efficiency even if you don't use the return value for anything. The compiler will
  be able to optimize the assignment of the return value completely away if it's not used.)</p>

<p>Example:</p>

<pre>WMPUInt&lt;64&gt; value, result;
std::uint64_t divisor = 1234567;

std::uint64_t remainder = value.divide(divisor, result);</pre>

<p>If you only require the remainder of the <code>WMPUInt</code> object divided by a
  <code>std::uint64_t</code> value, using the <code>modulo()</code> function is more convenient
  and slightly more optimal (because the quotient will not be needlessly stored anywhere).
  Example:</p>

<pre>WMPUInt&lt;64&gt; value;
std::uint64_t divisor = 1234567;

std::uint64_t remainder = value.modulo(divisor);</pre>

<p><b class="important">Important!</b> Note that <code>divide()</code> and <code>modulo()</code>
  do <em>not</em> check if the divisor is zero. If it is, this will most probably cause a CPU
  exception to be thrown. Doing this check is up to the calling code, if needed, before calling
  these functions.</p>


<!---------------------------------------------------------------------------->
<h3 id="bitshift">Bit-shifting by a compile-time constant</h3>

<p><b>Member functions:</b></p>

<pre class="synopsis">template&lt;std::size_t kBits&gt; void <span class="funcname">shiftLeft</span> ();
template&lt;std::size_t kBits&gt; void <span class="funcname">shiftRight</span> ();</pre>

<p>These functions do essentially the same thing as <code>operator&lt;&lt;=</code> and
  <code>operator&gt;&gt;=</code>, except that the amount of bits to shift is determined
  at compile time, as a secondary template parameter. When this amount is known at compile
  time, it may lead to more more efficient code.</p>

<p>Note that unlike with the operators, with these functions shifting by an amount larger
  than or equal to <code>bits()</code> is not undefined behavior (instead, the object will be
  zeroed).</p>

<p>Example:</p>

<pre>WMPUInt&lt;64&gt; value;
value.shiftLeft&lt;192&gt;(); <span class="comment">// Shift left by 192 bits</span></pre>


<!---------------------------------------------------------------------------->
<h2 id="printing">ASCII output</h2>
<h3>Output in hexadecimal format</h3>

<p><b>Member functions:</b></p>

<pre class="synopsis">constexpr static std::size_t <span class="funcname">maxHexadecimalDigits</span> ();
void <span class="funcname">printAsHexStr</span> (char* destination) const;</pre>

<p><code>printAsHexStr()</code> can be used to print the value of this object as an
  ASCII string in hexadecimal format. The length of the output can be determined using
  the <code>maxHexadecimalDigits()</code> constexpr function (the return value is always
  <code>kSize*16</code>, but this function is provided for convenience.).</p>

<p>This function will always print <code>maxHexadecimalDigits()</code> characters
  (with leading <code>'0'</code> characters if needed).</p>

<p>Note that this function does not output an ending null character.</p>

<p>Example:</p>

<pre>WMPUInt&lt;8&gt; number;
char str[number.maxHexadecimalDigits() + 1] = {};
number.printAsHexStr(str);
std::cout &lt;&lt; "The number is " &lt;&lt; str &lt;&lt; "\n";</pre>

<h3>Output in decimal format</h3>

<p><b>Member functions:</b></p>

<pre class="synopsis">constexpr static std::size_t <span class="funcname">maxDecimalDigits</span> ();
char* <span class="funcname">printAsDecStr</span> (char* destination) const;
char* <span class="funcname">printAsDecStr</span> (char* destination, WMPUInt&lt;kSize&gt;&amp; temp) const;
char* <span class="funcname">printAsDecStrAndReset</span> (char* destination);</pre>

<p>These functions can be used to output the value in decimal format. The <code>destination</code>
  char array must contain at least <code>maxDecimalDigits()</code> elements.</p>

<p>Note that these functions will output the characters at the <em>end</em> of the destination
  array. The return value is a pointer to the beginning of the outputted string. The contents
  of the array prior to that point will be unmodified. The result will have no leading
  <code>'0'</code> characters.</p>

<p>Note that these functions do not output an ending null character.</p>

<p>Example:</p>

<pre>WMPUInt&lt;4&gt; value;
value.assignFromDecStr("123456789012345678901234567890");

const std::size_t kMaxDigits = WMPUInt&lt;4&gt;::maxDecimalDigits();
char str[kMaxDigits + 1];
str[kMaxDigits] = 0;

std::cout &lt;&lt; value.printAsDecStr(str) &lt;&lt; "\n";</pre>

<p>Note that in order to create the output string, <code>printAsDecStr()</code> needs to copy
  the value into a temporary buffer in order to modify it. The second version of the function
  takes this temporary buffer as parameter (which may be necessary for very large values).
  Example:</p>

<pre>WMPUInt&lt;1024&gt; value, temp;
value.printAsDecStr(destination, temp);</pre>

<p>This temporary buffer can be avoided completely if it's acceptable for the object that's
  being printed to be zeroed. This can be done with the <code>printAsDecStrAndReset()</code>
  function. This version does not require any temporary buffer, and the value will be set to
  zero when it returns.</p>

<p>Expanding <code>std::ostream</code> to support (relatively small) <code>WMPUInt</code>
  values could be done for example like this:</p>

<pre>template&lt;std::size_t kSize&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const WMPUInt&lt;kSize&gt;&amp; value)
{
    const std::size_t kMaxDigits = WMPUInt&lt;kSize&gt;::maxDecimalDigits();
    char str[kMaxDigits + 1];
    str[kMaxDigits] = 0;
    return os &lt;&lt; value.printAsDecStr(str);
}

void foo()
{
    WMPUInt&lt;2&gt; value;
    value.assignFromDecStr("123456789012345678901234567890");
    std::cout &lt;&lt; "Value is: " &lt;&lt; value &lt;&lt; "\n";
}
</pre>

<!---------------------------------------------------------------------------->
<h2 id="notyetsupported">Not yet supported features</h2>

<p>These missing features will be added in a later update:</p>

<ul>
  <li>Division operators.</li>
  <li>Modulo operators.</li>
  <li>A <code>divmod()</code> function that returns both the result and remainder of division.</li>
  <li>A signed version of the class, <code>WMPInt</code>.</li>
</ul>

<p>Possible future improvements:</p>

<ul>
  <li>A fixed-point arithmetic specialization class.</li>
</ul>

<!---------------------------------------------------------------------------->
<h2 id="tips">Efficiency tips</h2>

<h3 id="copying">Copying and temporaries</h3>

<p>These classes behave in the exact same way as
  <code>std::array&lt;std::uint64_t, kSize&gt;</code>, so the same considerations apply
  with regards to storage and copying.</p>

<p>For maximum efficiency, needless temporaries and copying should be avoided. The larger
  the classes are, the more important to avoid them. For example, instead of:</p>

<pre>a = b + c + d - e;</pre>

<p>prefer:</p>

<pre>a = b;
a += c;
a += d;
a -= e;</pre>

<p>Note that the unary negation operator will <em>always</em> calculate the result into
  and return a temporary. Thus it ought to be avoided if possible, and the member function
  <code>neg()</code> used instead. In other words, instead of doing:</p>

<pre>a = -a;</pre>

<p>prefer:</p>

<pre>a.neg();</pre>

<p>Also avoid passing objects of these types to functions by value and prefer passing them
  by reference, unless you really need a local copy of the parameter. In other words,
  instead of doing:</p>

<pre>void foo(WMPUInt&lt;128&gt; value1, WMPUInt&lt;128&gt; value2);</pre>

<p>prefer:</p>

<pre>void foo(const WMPUInt&lt;128&gt;&amp; value1, const WMPUInt&lt;128&gt;&amp; value2);</pre>

<!---------------------------------------------------------------------------->
<h3 id="smalloperands">Small operands</h3>

<p>In general, the versions of the operators and functions that take a <code>std::uint64_t</code>
  as parameter are significantly faster then the ones that take a <code>WMPUInt</code> as
  parameter. Therefore if the value of the right-hand-side operand is small enough to fit in
  a 64-bit value, it should be used as such.</p>

<p>In other words, instead of:</p>

<pre>WMPUInt&lt;256&gt; value1, value2, value3;
WMPUInt&lt;256&gt; operand(10);

value1 += operand;
value2 -= operand;
value3 *= operand;</pre>

<p>prefer:</p>

<pre>WMPUInt&lt;256&gt; value1, value2, value3;
std::uint64_t operand = 10;

value1 += operand;
value2 -= operand;
value3 *= operand;

<span class="comment">// or simply:</span>
value1 += 10;
value2 -= 10;
value3 *= 10;</pre>

<!---------------------------------------------------------------------------->
<h3 id="multiplication">Multiplication</h3>

<p>Take note of the earlier section <a href="#multiply">Multiplying very large integers</a>.
  While this is important with very large objects, the copying that's happening with
  <code>operator*()</code> and <code>operator*=()</code> may also be an efficiency concern even
  with more moderately-sized objects. If this copying of objects turns out to have a negative
  impact on efficiency, the <code>multiply()</code> member function can be used to elide this
  copying completely, for example like this:</p>

<pre>WMPUInt&lt;128&gt; v1, v2, result; <span class="comment">// 8192-bit integers</span>

<span class="comment">// Multiply without any data copying:</span>
std::uint64_t tempBuffer[WMPUInt&lt;128&gt;::multiplyBufferSize()];
v1.multiply(v2, result, tempBuffer);</pre>

<p>(Note that <code>v1</code> and <code>v2</code> above can <em>not</em> be used
  as the second (ie. result) parameter to the function, as this would simply give a completely
  incorrect result. The result must always be calculated into a third object.)</p>

<!---------------------------------------------------------------------------->
<h3 id="exproptimization">Expression optimizations</h3>

<p>Note that even though these classes behave like they were integers, the compiler will not
  consider them such, and therefore will be unable to perform any expression optimizations.
  Any such optimizations should be done by hand.</p>

<p>For example, the compiler will not be able to optimize repeated expressions to be calculated
  only once, such as:</p>

<pre>result = (a + b + c) * (a + b + c);</pre>

<p>Such an expression will needlessly make those summations twice. It should be optimized
  manually into something like:</p>

<pre>result = a;
result += b;
result += c;
result *= result;</pre>

<p>Also, multiplications are genuinely and significantly slower than additions, and such
  the former should be manually optimized into the latter whenever possible. For example,
  instead of doing:</p>

<pre>a *= 2;</pre>

<p>prefer:</p>

<pre>a += a;</pre>

<!---------------------------------------------------------------------------->
<h3 id="longvskaratsuba">Full multiplication with long vs. Karatsuba algorithm</h3>

<p>The <code>fullMultiply()</code> function, which calculates the full non-truncated result
  of the product of two values, will use either the long multiplication or the Karatsuba
  multiplication algorithm, depending on the size of the operands. The heuristic to choose
  between the two is relatively simplistic, and the faster one might not always be chosen
  in every single case. Calling either algorithm directly is supported, to give the user the
  possibility of bypassing this simplistic heuristic in cases where the chosen one is not
  actually the more efficient, for a particular pair of sizes.</p>

<p>This is mostly relevant only if you are using <code>fullMultiply()</code> on values of
  different sizes. If they are of the same size, you most likely don't need to worry about it.
  However, if you are multiplying values of very different sizes, especially if these values
  are very large (the <code>kSize</code> template parameter in the thousands or more), it may
  be worth checking if calling one of the algorithms or the other directly might be faster
  than relying on the default choice.</p>

<p>The current choice heuristic is the following. The long multiplication algorithm will be
  chosen if any of these is true:</p>

<ul>
  <li>The <code>kSize</code> of both numbers is the same, and this size is less than 16.</li>
  <li>The larger <code>kSize</code> is less than 50, and the smaller <code>kSize</code> is less
    than half the larger one.</li>
  <li>The larger <code>kSize</code> is between 50 and 199, and the smaller <code>kSize</code> is
    less than a third of the larger one.</li>
  <li>The larger <code>kSize</code> is 200 or more, and the smaller <code>kSize</code> is
    less than a quarter of the larger one.</li>
</ul>

<p>Else the Karatsuba algorithm will be used.</p>

<p>If you are using <code>fullMultiply</code> on very large numbers of very different sizes,
  and using the optimal algorithm is crucial, it may be worth trying calling one algorithm or
  the other directly.</p>

<p><b>Member functions:</b></p>

<pre class="synopsis">template&lt;std::size_t kSize2&gt;
constexpr static std::size_t <span class="funcname">fullMultiply_longMultiplicationBufferSize</span>();

template&lt;std::size_t kSize2&gt;
void <span class="funcname">fullMultiply_longMultiplication</span>
(const WMPUInt&lt;kSize2&gt;&amp;, WMPUInt&lt;kSize+kSize2&gt;&amp; result,
 std::uint64_t* tempBuffer) const;

template&lt;std::size_t kSize2&gt;
constexpr static std::size_t <span class="funcname">fullMultiply_karatsubaBufferSize</span>();

template&lt;std::size_t kSize2&gt;
void <span class="funcname">fullMultiply_karatsuba</span>
(const WMPUInt&lt;kSize2&gt;&amp;, WMPUInt&lt;kSize+kSize2&gt;&amp; result,
 std::uint64_t* tempBuffer) const;</pre>

<p>Only versions that take a temporary buffer for calculations are provided. Be sure to get its
  size using the corresponding function.</p>

<p>Example:</p>

<pre>WMPUInt&lt;2048&gt; value1;
WMPUInt&lt;256&gt; value2;
WMPUInt&lt;2048+256&gt; result;

constexpr std::size_t kTempBufferSize =
    WMPUInt&lt;2048&gt;::fullMultiply_karatsubaBufferSize&lt;256&gt;();
std::uint64_t tempBuffer[kTempBufferSize];

value1.fullMultiply_karatsuba(value2, result, tempBuffer);</pre>

<!---------------------------------------------------------------------------->
<h3 id="extremelylargevalues">Creating extremely large values</h3>

<p><code>WMPUInt</code> works in the same way as an <code>std::array</code> of
  <code>std::uint64_t</code> values, in that all the data is kept as a member array
  (rather than being dynamically allocated). This is very efficient with relatively
  small values (up to sizes in the thousands), but may become a problem with extremely
  large values because of limited stack space.</p>

<p>In the case of such enormous values it's more advisable to allocate the <code>WMPUInt</code>
  objects dynamically. It's recommended to use for example <code>std::unique_ptr</code> or
  <code>std::shared_ptr</code> to manage them.</p>

<p>Example of <code>WMPUInt</code> values of size 65536 (4194304‬ bits):</p>

<pre><span class="comment">/* Constants and types*/</span>
const std::size_t kSize = 65536;
using UInt_t = WMPUInt&lt;kSize&gt;;
using Result_t = WMPUInt&lt;kSize*2&gt;;
const std::size_t kFullMultBufferSize =
    UInt_t::fullMultiplyBufferSize&lt;kSize&gt;();

<span class="comment">/* Dynamically allocated big numbers */</span>
std::unique_ptr&lt;UInt_t&gt; value1(new UInt_t);
std::unique_ptr&lt;UInt_t&gt; value2(new UInt_t);
std::unique_ptr&lt;Result_t&gt; result(new Result_t);

std::unique_ptr&lt;std::uint64_t[]&gt; tempBuffer
    (new std::uint64_t[kFullMultBufferSize]);</pre>

<p>Example use of the above (multiply the two values, measure the time):</p>

<pre><span class="comment">/* Initialize with random values */</span>
std::mt19937_64 rng;
for(std::size_t i = 0; i &lt; kSize; ++i) value1-&gt;data()[i] = rng();
for(std::size_t i = 0; i &lt; kSize; ++i) value2-&gt;data()[i] = rng();

<span class="comment">/* Multiply and measure time */</span>
auto startTime = std::chrono::high_resolution_clock::now();

value1-&gt;fullMultiply(*value2, *result, tempBuffer.get());

auto endTime = std::chrono::high_resolution_clock::now();
std::chrono::duration&lt;double&gt; diff = endTime - startTime;
const double seconds = diff.count();

std::cout &lt;&lt; "Duration: " &lt;&lt; seconds &lt;&lt; " seconds\n";</pre>

</body></html>
